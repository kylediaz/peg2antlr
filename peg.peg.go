package main

// Code generated by peg -syntax peg.peg DO NOT EDIT.

import (
	"bytes"
	"fmt"
	"github.com/pointlander/peg/tree"
	"io"
	"os"
	"sort"
	"strconv"
)

const endSymbol rune = 1114112

/* The rule types inferred from the grammar are below. */
type pegRule uint8

const (
	ruleUnknown pegRule = iota
	ruleGrammar
	ruleImport
	ruleSingleImport
	ruleMultiImport
	ruleImportName
	ruleDefinition
	ruleExpression
	ruleSequence
	rulePrefix
	ruleSuffix
	rulePrimary
	ruleIdentifier
	ruleIdentStart
	ruleIdentCont
	ruleLiteral
	ruleClass
	ruleRanges
	ruleDoubleRanges
	ruleRange
	ruleDoubleRange
	ruleChar
	ruleDoubleChar
	ruleEscape
	ruleLeftArrow
	ruleSlash
	ruleAnd
	ruleNot
	ruleQuestion
	ruleStar
	rulePlus
	ruleOpen
	ruleClose
	ruleDot
	ruleSpaceComment
	ruleSpacing
	ruleMustSpacing
	ruleComment
	ruleSpace
	ruleEndOfLine
	ruleEndOfFile
	ruleAction
	ruleActionBody
	ruleBegin
	ruleEnd
	ruleAction0
	ruleAction1
	ruleAction2
	rulePegText
	ruleAction3
	ruleAction4
	ruleAction5
	ruleAction6
	ruleAction7
	ruleAction8
	ruleAction9
	ruleAction10
	ruleAction11
	ruleAction12
	ruleAction13
	ruleAction14
	ruleAction15
	ruleAction16
	ruleAction17
	ruleAction18
	ruleAction19
	ruleAction20
	ruleAction21
	ruleAction22
	ruleAction23
	ruleAction24
	ruleAction25
	ruleAction26
	ruleAction27
	ruleAction28
	ruleAction29
	ruleAction30
	ruleAction31
	ruleAction32
	ruleAction33
	ruleAction34
	ruleAction35
	ruleAction36
	ruleAction37
	ruleAction38
	ruleAction39
	ruleAction40
	ruleAction41
	ruleAction42
	ruleAction43
	ruleAction44
	ruleAction45
	ruleAction46
	ruleAction47
	ruleAction48
)

var rul3s = [...]string{
	"Unknown",
	"Grammar",
	"Import",
	"SingleImport",
	"MultiImport",
	"ImportName",
	"Definition",
	"Expression",
	"Sequence",
	"Prefix",
	"Suffix",
	"Primary",
	"Identifier",
	"IdentStart",
	"IdentCont",
	"Literal",
	"Class",
	"Ranges",
	"DoubleRanges",
	"Range",
	"DoubleRange",
	"Char",
	"DoubleChar",
	"Escape",
	"LeftArrow",
	"Slash",
	"And",
	"Not",
	"Question",
	"Star",
	"Plus",
	"Open",
	"Close",
	"Dot",
	"SpaceComment",
	"Spacing",
	"MustSpacing",
	"Comment",
	"Space",
	"EndOfLine",
	"EndOfFile",
	"Action",
	"ActionBody",
	"Begin",
	"End",
	"Action0",
	"Action1",
	"Action2",
	"PegText",
	"Action3",
	"Action4",
	"Action5",
	"Action6",
	"Action7",
	"Action8",
	"Action9",
	"Action10",
	"Action11",
	"Action12",
	"Action13",
	"Action14",
	"Action15",
	"Action16",
	"Action17",
	"Action18",
	"Action19",
	"Action20",
	"Action21",
	"Action22",
	"Action23",
	"Action24",
	"Action25",
	"Action26",
	"Action27",
	"Action28",
	"Action29",
	"Action30",
	"Action31",
	"Action32",
	"Action33",
	"Action34",
	"Action35",
	"Action36",
	"Action37",
	"Action38",
	"Action39",
	"Action40",
	"Action41",
	"Action42",
	"Action43",
	"Action44",
	"Action45",
	"Action46",
	"Action47",
	"Action48",
}

type token32 struct {
	pegRule
	begin, end uint32
}

func (t *token32) String() string {
	return fmt.Sprintf("\x1B[34m%v\x1B[m %v %v", rul3s[t.pegRule], t.begin, t.end)
}

type node32 struct {
	token32
	up, next *node32
}

func (node *node32) print(w io.Writer, pretty bool, buffer string) {
	var print func(node *node32, depth int)
	print = func(node *node32, depth int) {
		for node != nil {
			for c := 0; c < depth; c++ {
				fmt.Fprintf(w, " ")
			}
			rule := rul3s[node.pegRule]
			quote := strconv.Quote(string(([]rune(buffer)[node.begin:node.end])))
			if !pretty {
				fmt.Fprintf(w, "%v %v\n", rule, quote)
			} else {
				fmt.Fprintf(w, "\x1B[36m%v\x1B[m %v\n", rule, quote)
			}
			if node.up != nil {
				print(node.up, depth+1)
			}
			node = node.next
		}
	}
	print(node, 0)
}

func (node *node32) Print(w io.Writer, buffer string) {
	node.print(w, false, buffer)
}

func (node *node32) PrettyPrint(w io.Writer, buffer string) {
	node.print(w, true, buffer)
}

type tokens32 struct {
	tree []token32
}

func (t *tokens32) Trim(length uint32) {
	t.tree = t.tree[:length]
}

func (t *tokens32) Print() {
	for _, token := range t.tree {
		fmt.Println(token.String())
	}
}

func (t *tokens32) AST() *node32 {
	type element struct {
		node *node32
		down *element
	}
	tokens := t.Tokens()
	var stack *element
	for _, token := range tokens {
		if token.begin == token.end {
			continue
		}
		node := &node32{token32: token}
		for stack != nil && stack.node.begin >= token.begin && stack.node.end <= token.end {
			stack.node.next = node.up
			node.up = stack.node
			stack = stack.down
		}
		stack = &element{node: node, down: stack}
	}
	if stack != nil {
		return stack.node
	}
	return nil
}

func (t *tokens32) PrintSyntaxTree(buffer string) {
	t.AST().Print(os.Stdout, buffer)
}

func (t *tokens32) WriteSyntaxTree(w io.Writer, buffer string) {
	t.AST().Print(w, buffer)
}

func (t *tokens32) PrettyPrintSyntaxTree(buffer string) {
	t.AST().PrettyPrint(os.Stdout, buffer)
}

func (t *tokens32) Add(rule pegRule, begin, end, index uint32) {
	tree, i := t.tree, int(index)
	if i >= len(tree) {
		t.tree = append(tree, token32{pegRule: rule, begin: begin, end: end})
		return
	}
	tree[i] = token32{pegRule: rule, begin: begin, end: end}
}

func (t *tokens32) Tokens() []token32 {
	return t.tree
}

type Peg struct {
	*tree.Tree

	Buffer         string
	buffer         []rune
	rules          [95]func() bool
	parse          func(rule ...int) error
	reset          func()
	Pretty         bool
	disableMemoize bool
	tokens32
}

func (p *Peg) Parse(rule ...int) error {
	return p.parse(rule...)
}

func (p *Peg) Reset() {
	p.reset()
}

type textPosition struct {
	line, symbol int
}

type textPositionMap map[int]textPosition

func translatePositions(buffer []rune, positions []int) textPositionMap {
	length, translations, j, line, symbol := len(positions), make(textPositionMap, len(positions)), 0, 1, 0
	sort.Ints(positions)

search:
	for i, c := range buffer {
		if c == '\n' {
			line, symbol = line+1, 0
		} else {
			symbol++
		}
		if i == positions[j] {
			translations[positions[j]] = textPosition{line, symbol}
			for j++; j < length; j++ {
				if i != positions[j] {
					continue search
				}
			}
			break search
		}
	}

	return translations
}

type parseError struct {
	p   *Peg
	max token32
}

func (e *parseError) Error() string {
	tokens, err := []token32{e.max}, "\n"
	positions, p := make([]int, 2*len(tokens)), 0
	for _, token := range tokens {
		positions[p], p = int(token.begin), p+1
		positions[p], p = int(token.end), p+1
	}
	translations := translatePositions(e.p.buffer, positions)
	format := "parse error near %v (line %v symbol %v - line %v symbol %v):\n%v\n"
	if e.p.Pretty {
		format = "parse error near \x1B[34m%v\x1B[m (line %v symbol %v - line %v symbol %v):\n%v\n"
	}
	for _, token := range tokens {
		begin, end := int(token.begin), int(token.end)
		err += fmt.Sprintf(format,
			rul3s[token.pegRule],
			translations[begin].line, translations[begin].symbol,
			translations[end].line, translations[end].symbol,
			strconv.Quote(string(e.p.buffer[begin:end])))
	}

	return err
}

func (p *Peg) PrintSyntaxTree() {
	if p.Pretty {
		p.tokens32.PrettyPrintSyntaxTree(p.Buffer)
	} else {
		p.tokens32.PrintSyntaxTree(p.Buffer)
	}
}

func (p *Peg) WriteSyntaxTree(w io.Writer) {
	p.tokens32.WriteSyntaxTree(w, p.Buffer)
}

func (p *Peg) SprintSyntaxTree() string {
	var b bytes.Buffer
	p.WriteSyntaxTree(&b)
	return b.String()
}

func (p *Peg) Execute() {
	buffer, _buffer, text, begin, end := p.Buffer, p.buffer, "", 0, 0
	for _, token := range p.Tokens() {
		switch token.pegRule {

		case rulePegText:
			begin, end = int(token.begin), int(token.end)
			text = string(_buffer[begin:end])

		case ruleAction0:
			p.AddPackage(text)
		case ruleAction1:
			p.AddPeg(text)
		case ruleAction2:
			p.AddState(text)
		case ruleAction3:
			p.AddImport(text)
		case ruleAction4:
			p.AddRule(text)
		case ruleAction5:
			p.AddExpression()
		case ruleAction6:
			p.AddAlternate()
		case ruleAction7:
			p.AddNil()
			p.AddAlternate()
		case ruleAction8:
			p.AddNil()
		case ruleAction9:
			p.AddSequence()
		case ruleAction10:
			p.AddPredicate(text)
		case ruleAction11:
			p.AddStateChange(text)
		case ruleAction12:
			p.AddPeekFor()
		case ruleAction13:
			p.AddPeekNot()
		case ruleAction14:
			p.AddQuery()
		case ruleAction15:
			p.AddStar()
		case ruleAction16:
			p.AddPlus()
		case ruleAction17:
			p.AddName(text)
		case ruleAction18:
			p.AddDot()
		case ruleAction19:
			p.AddAction(text)
		case ruleAction20:
			p.AddPush()
		case ruleAction21:
			p.AddSequence()
		case ruleAction22:
			p.AddSequence()
		case ruleAction23:
			p.AddPeekNot()
			p.AddDot()
			p.AddSequence()
		case ruleAction24:
			p.AddPeekNot()
			p.AddDot()
			p.AddSequence()
		case ruleAction25:
			p.AddAlternate()
		case ruleAction26:
			p.AddAlternate()
		case ruleAction27:
			p.AddRange()
		case ruleAction28:
			p.AddDoubleRange()
		case ruleAction29:
			p.AddCharacter(text)
		case ruleAction30:
			p.AddDoubleCharacter(text)
		case ruleAction31:
			p.AddCharacter(text)
		case ruleAction32:
			p.AddCharacter("\a")
		case ruleAction33:
			p.AddCharacter("\b")
		case ruleAction34:
			p.AddCharacter("\x1B")
		case ruleAction35:
			p.AddCharacter("\f")
		case ruleAction36:
			p.AddCharacter("\n")
		case ruleAction37:
			p.AddCharacter("\r")
		case ruleAction38:
			p.AddCharacter("\t")
		case ruleAction39:
			p.AddCharacter("\v")
		case ruleAction40:
			p.AddCharacter("'")
		case ruleAction41:
			p.AddCharacter("\"")
		case ruleAction42:
			p.AddCharacter("[")
		case ruleAction43:
			p.AddCharacter("]")
		case ruleAction44:
			p.AddCharacter("-")
		case ruleAction45:
			p.AddHexaCharacter(text)
		case ruleAction46:
			p.AddOctalCharacter(text)
		case ruleAction47:
			p.AddOctalCharacter(text)
		case ruleAction48:
			p.AddCharacter("\\")

		}
	}
	_, _, _, _, _ = buffer, _buffer, text, begin, end
}

func Pretty(pretty bool) func(*Peg) error {
	return func(p *Peg) error {
		p.Pretty = pretty
		return nil
	}
}

func Size(size int) func(*Peg) error {
	return func(p *Peg) error {
		p.tokens32 = tokens32{tree: make([]token32, 0, size)}
		return nil
	}
}

func DisableMemoize() func(*Peg) error {
	return func(p *Peg) error {
		p.disableMemoize = true
		return nil
	}
}

type memo struct {
	Matched bool
	Partial []token32
}

type memoKey struct {
	Rule     uint32
	Position uint32
}

func (p *Peg) Init(options ...func(*Peg) error) error {
	var (
		max                  token32
		position, tokenIndex uint32
		buffer               []rune
		memoization          map[memoKey]memo
	)
	for _, option := range options {
		err := option(p)
		if err != nil {
			return err
		}
	}
	p.reset = func() {
		max = token32{}
		position, tokenIndex = 0, 0
		memoization = make(map[memoKey]memo)
		p.buffer = []rune(p.Buffer)
		if len(p.buffer) == 0 || p.buffer[len(p.buffer)-1] != endSymbol {
			p.buffer = append(p.buffer, endSymbol)
		}
		buffer = p.buffer
	}
	p.reset()

	_rules := p.rules
	tree := p.tokens32
	p.parse = func(rule ...int) error {
		r := 1
		if len(rule) > 0 {
			r = rule[0]
		}
		matches := p.rules[r]()
		p.tokens32 = tree
		if matches {
			p.Trim(tokenIndex)
			return nil
		}
		return &parseError{p, max}
	}

	add := func(rule pegRule, begin uint32) {
		tree.Add(rule, begin, position, tokenIndex)
		tokenIndex++
		if begin != position && position > max.end {
			max = token32{rule, begin, position}
		}
	}

	memoize := func(rule uint32, begin uint32, tokenIndexStart uint32, matched bool) {
		if p.disableMemoize {
			return
		}
		key := memoKey{rule, begin}
		if !matched {
			memoization[key] = memo{Matched: false}
		} else {
			t := tree.tree[tokenIndexStart:tokenIndex]
			tokenCopy := make([]token32, len(t))
			copy(tokenCopy, t)
			memoization[key] = memo{Matched: true, Partial: tokenCopy}
		}
	}

	memoizedResult := func(m memo) bool {
		if !m.Matched {
			return false
		}
		tree.tree = append(tree.tree[:tokenIndex], m.Partial...)
		tokenIndex += uint32(len(m.Partial))
		position = m.Partial[len(m.Partial)-1].end
		if tree.tree[tokenIndex-1].begin != position && position > max.end {
			max = tree.tree[tokenIndex-1]
		}
		return true
	}

	matchDot := func() bool {
		if buffer[position] != endSymbol {
			position++
			return true
		}
		return false
	}

	/*matchChar := func(c byte) bool {
		if buffer[position] == c {
			position++
			return true
		}
		return false
	}*/

	/*matchRange := func(lower byte, upper byte) bool {
		if c := buffer[position]; c >= lower && c <= upper {
			position++
			return true
		}
		return false
	}*/

	_rules = [...]func() bool{
		nil,
		/* 0 Grammar <- <(Spacing ('p' 'a' 'c' 'k' 'a' 'g' 'e') MustSpacing Identifier Action0 Import* ('t' 'y' 'p' 'e') MustSpacing Identifier Action1 ('P' 'e' 'g') Spacing Action Action2 Definition+ EndOfFile)> */
		func() bool {
			if memoized, ok := memoization[memoKey{0, position}]; ok {
				return memoizedResult(memoized)
			}
			position0, tokenIndex0 := position, tokenIndex
			{
				position1 := position
				if !_rules[ruleSpacing]() {
					goto l0
				}
				if buffer[position] != rune('p') {
					goto l0
				}
				position++
				if buffer[position] != rune('a') {
					goto l0
				}
				position++
				if buffer[position] != rune('c') {
					goto l0
				}
				position++
				if buffer[position] != rune('k') {
					goto l0
				}
				position++
				if buffer[position] != rune('a') {
					goto l0
				}
				position++
				if buffer[position] != rune('g') {
					goto l0
				}
				position++
				if buffer[position] != rune('e') {
					goto l0
				}
				position++
				if !_rules[ruleMustSpacing]() {
					goto l0
				}
				if !_rules[ruleIdentifier]() {
					goto l0
				}
				if !_rules[ruleAction0]() {
					goto l0
				}
			l2:
				{
					position3, tokenIndex3 := position, tokenIndex
					if !_rules[ruleImport]() {
						goto l3
					}
					goto l2
				l3:
					position, tokenIndex = position3, tokenIndex3
				}
				if buffer[position] != rune('t') {
					goto l0
				}
				position++
				if buffer[position] != rune('y') {
					goto l0
				}
				position++
				if buffer[position] != rune('p') {
					goto l0
				}
				position++
				if buffer[position] != rune('e') {
					goto l0
				}
				position++
				if !_rules[ruleMustSpacing]() {
					goto l0
				}
				if !_rules[ruleIdentifier]() {
					goto l0
				}
				if !_rules[ruleAction1]() {
					goto l0
				}
				if buffer[position] != rune('P') {
					goto l0
				}
				position++
				if buffer[position] != rune('e') {
					goto l0
				}
				position++
				if buffer[position] != rune('g') {
					goto l0
				}
				position++
				if !_rules[ruleSpacing]() {
					goto l0
				}
				if !_rules[ruleAction]() {
					goto l0
				}
				if !_rules[ruleAction2]() {
					goto l0
				}
				if !_rules[ruleDefinition]() {
					goto l0
				}
			l4:
				{
					position5, tokenIndex5 := position, tokenIndex
					if !_rules[ruleDefinition]() {
						goto l5
					}
					goto l4
				l5:
					position, tokenIndex = position5, tokenIndex5
				}
				if !_rules[ruleEndOfFile]() {
					goto l0
				}
				add(ruleGrammar, position1)
			}
			memoize(0, position0, tokenIndex0, true)
			return true
		l0:
			memoize(0, position0, tokenIndex0, false)
			position, tokenIndex = position0, tokenIndex0
			return false
		},
		/* 1 Import <- <('i' 'm' 'p' 'o' 'r' 't' Spacing (MultiImport / SingleImport) Spacing)> */
		func() bool {
			if memoized, ok := memoization[memoKey{1, position}]; ok {
				return memoizedResult(memoized)
			}
			position6, tokenIndex6 := position, tokenIndex
			{
				position7 := position
				if buffer[position] != rune('i') {
					goto l6
				}
				position++
				if buffer[position] != rune('m') {
					goto l6
				}
				position++
				if buffer[position] != rune('p') {
					goto l6
				}
				position++
				if buffer[position] != rune('o') {
					goto l6
				}
				position++
				if buffer[position] != rune('r') {
					goto l6
				}
				position++
				if buffer[position] != rune('t') {
					goto l6
				}
				position++
				if !_rules[ruleSpacing]() {
					goto l6
				}
				{
					position8, tokenIndex8 := position, tokenIndex
					if !_rules[ruleMultiImport]() {
						goto l9
					}
					goto l8
				l9:
					position, tokenIndex = position8, tokenIndex8
					if !_rules[ruleSingleImport]() {
						goto l6
					}
				}
			l8:
				if !_rules[ruleSpacing]() {
					goto l6
				}
				add(ruleImport, position7)
			}
			memoize(1, position6, tokenIndex6, true)
			return true
		l6:
			memoize(1, position6, tokenIndex6, false)
			position, tokenIndex = position6, tokenIndex6
			return false
		},
		/* 2 SingleImport <- <ImportName> */
		func() bool {
			if memoized, ok := memoization[memoKey{2, position}]; ok {
				return memoizedResult(memoized)
			}
			position10, tokenIndex10 := position, tokenIndex
			{
				position11 := position
				if !_rules[ruleImportName]() {
					goto l10
				}
				add(ruleSingleImport, position11)
			}
			memoize(2, position10, tokenIndex10, true)
			return true
		l10:
			memoize(2, position10, tokenIndex10, false)
			position, tokenIndex = position10, tokenIndex10
			return false
		},
		/* 3 MultiImport <- <('(' Spacing (ImportName '\n' Spacing)* Spacing ')')> */
		func() bool {
			if memoized, ok := memoization[memoKey{3, position}]; ok {
				return memoizedResult(memoized)
			}
			position12, tokenIndex12 := position, tokenIndex
			{
				position13 := position
				if buffer[position] != rune('(') {
					goto l12
				}
				position++
				if !_rules[ruleSpacing]() {
					goto l12
				}
			l14:
				{
					position15, tokenIndex15 := position, tokenIndex
					if !_rules[ruleImportName]() {
						goto l15
					}
					if buffer[position] != rune('\n') {
						goto l15
					}
					position++
					if !_rules[ruleSpacing]() {
						goto l15
					}
					goto l14
				l15:
					position, tokenIndex = position15, tokenIndex15
				}
				if !_rules[ruleSpacing]() {
					goto l12
				}
				if buffer[position] != rune(')') {
					goto l12
				}
				position++
				add(ruleMultiImport, position13)
			}
			memoize(3, position12, tokenIndex12, true)
			return true
		l12:
			memoize(3, position12, tokenIndex12, false)
			position, tokenIndex = position12, tokenIndex12
			return false
		},
		/* 4 ImportName <- <('"' <([0-9] / [a-z] / [A-Z] / '_' / '/' / '.' / '-')+> '"' Action3)> */
		func() bool {
			if memoized, ok := memoization[memoKey{4, position}]; ok {
				return memoizedResult(memoized)
			}
			position16, tokenIndex16 := position, tokenIndex
			{
				position17 := position
				if buffer[position] != rune('"') {
					goto l16
				}
				position++
				{
					position18 := position
					{
						position21, tokenIndex21 := position, tokenIndex
						if c := buffer[position]; c < rune('0') || c > rune('9') {
							goto l22
						}
						position++
						goto l21
					l22:
						position, tokenIndex = position21, tokenIndex21
						if c := buffer[position]; c < rune('a') || c > rune('z') {
							goto l23
						}
						position++
						goto l21
					l23:
						position, tokenIndex = position21, tokenIndex21
						if c := buffer[position]; c < rune('A') || c > rune('Z') {
							goto l24
						}
						position++
						goto l21
					l24:
						position, tokenIndex = position21, tokenIndex21
						if buffer[position] != rune('_') {
							goto l25
						}
						position++
						goto l21
					l25:
						position, tokenIndex = position21, tokenIndex21
						if buffer[position] != rune('/') {
							goto l26
						}
						position++
						goto l21
					l26:
						position, tokenIndex = position21, tokenIndex21
						if buffer[position] != rune('.') {
							goto l27
						}
						position++
						goto l21
					l27:
						position, tokenIndex = position21, tokenIndex21
						if buffer[position] != rune('-') {
							goto l16
						}
						position++
					}
				l21:
				l19:
					{
						position20, tokenIndex20 := position, tokenIndex
						{
							position28, tokenIndex28 := position, tokenIndex
							if c := buffer[position]; c < rune('0') || c > rune('9') {
								goto l29
							}
							position++
							goto l28
						l29:
							position, tokenIndex = position28, tokenIndex28
							if c := buffer[position]; c < rune('a') || c > rune('z') {
								goto l30
							}
							position++
							goto l28
						l30:
							position, tokenIndex = position28, tokenIndex28
							if c := buffer[position]; c < rune('A') || c > rune('Z') {
								goto l31
							}
							position++
							goto l28
						l31:
							position, tokenIndex = position28, tokenIndex28
							if buffer[position] != rune('_') {
								goto l32
							}
							position++
							goto l28
						l32:
							position, tokenIndex = position28, tokenIndex28
							if buffer[position] != rune('/') {
								goto l33
							}
							position++
							goto l28
						l33:
							position, tokenIndex = position28, tokenIndex28
							if buffer[position] != rune('.') {
								goto l34
							}
							position++
							goto l28
						l34:
							position, tokenIndex = position28, tokenIndex28
							if buffer[position] != rune('-') {
								goto l20
							}
							position++
						}
					l28:
						goto l19
					l20:
						position, tokenIndex = position20, tokenIndex20
					}
					add(rulePegText, position18)
				}
				if buffer[position] != rune('"') {
					goto l16
				}
				position++
				if !_rules[ruleAction3]() {
					goto l16
				}
				add(ruleImportName, position17)
			}
			memoize(4, position16, tokenIndex16, true)
			return true
		l16:
			memoize(4, position16, tokenIndex16, false)
			position, tokenIndex = position16, tokenIndex16
			return false
		},
		/* 5 Definition <- <(Identifier Action4 LeftArrow Expression Action5 &((Identifier LeftArrow) / !.))> */
		func() bool {
			if memoized, ok := memoization[memoKey{5, position}]; ok {
				return memoizedResult(memoized)
			}
			position35, tokenIndex35 := position, tokenIndex
			{
				position36 := position
				if !_rules[ruleIdentifier]() {
					goto l35
				}
				if !_rules[ruleAction4]() {
					goto l35
				}
				if !_rules[ruleLeftArrow]() {
					goto l35
				}
				if !_rules[ruleExpression]() {
					goto l35
				}
				if !_rules[ruleAction5]() {
					goto l35
				}
				{
					position37, tokenIndex37 := position, tokenIndex
					{
						position38, tokenIndex38 := position, tokenIndex
						if !_rules[ruleIdentifier]() {
							goto l39
						}
						if !_rules[ruleLeftArrow]() {
							goto l39
						}
						goto l38
					l39:
						position, tokenIndex = position38, tokenIndex38
						{
							position40, tokenIndex40 := position, tokenIndex
							if !matchDot() {
								goto l40
							}
							goto l35
						l40:
							position, tokenIndex = position40, tokenIndex40
						}
					}
				l38:
					position, tokenIndex = position37, tokenIndex37
				}
				add(ruleDefinition, position36)
			}
			memoize(5, position35, tokenIndex35, true)
			return true
		l35:
			memoize(5, position35, tokenIndex35, false)
			position, tokenIndex = position35, tokenIndex35
			return false
		},
		/* 6 Expression <- <((Sequence (Slash Sequence Action6)* (Slash Action7)?) / Action8)> */
		func() bool {
			if memoized, ok := memoization[memoKey{6, position}]; ok {
				return memoizedResult(memoized)
			}
			position41, tokenIndex41 := position, tokenIndex
			{
				position42 := position
				{
					position43, tokenIndex43 := position, tokenIndex
					if !_rules[ruleSequence]() {
						goto l44
					}
				l45:
					{
						position46, tokenIndex46 := position, tokenIndex
						if !_rules[ruleSlash]() {
							goto l46
						}
						if !_rules[ruleSequence]() {
							goto l46
						}
						if !_rules[ruleAction6]() {
							goto l46
						}
						goto l45
					l46:
						position, tokenIndex = position46, tokenIndex46
					}
					{
						position47, tokenIndex47 := position, tokenIndex
						if !_rules[ruleSlash]() {
							goto l47
						}
						if !_rules[ruleAction7]() {
							goto l47
						}
						goto l48
					l47:
						position, tokenIndex = position47, tokenIndex47
					}
				l48:
					goto l43
				l44:
					position, tokenIndex = position43, tokenIndex43
					if !_rules[ruleAction8]() {
						goto l41
					}
				}
			l43:
				add(ruleExpression, position42)
			}
			memoize(6, position41, tokenIndex41, true)
			return true
		l41:
			memoize(6, position41, tokenIndex41, false)
			position, tokenIndex = position41, tokenIndex41
			return false
		},
		/* 7 Sequence <- <(Prefix (Prefix Action9)*)> */
		func() bool {
			if memoized, ok := memoization[memoKey{7, position}]; ok {
				return memoizedResult(memoized)
			}
			position49, tokenIndex49 := position, tokenIndex
			{
				position50 := position
				if !_rules[rulePrefix]() {
					goto l49
				}
			l51:
				{
					position52, tokenIndex52 := position, tokenIndex
					if !_rules[rulePrefix]() {
						goto l52
					}
					if !_rules[ruleAction9]() {
						goto l52
					}
					goto l51
				l52:
					position, tokenIndex = position52, tokenIndex52
				}
				add(ruleSequence, position50)
			}
			memoize(7, position49, tokenIndex49, true)
			return true
		l49:
			memoize(7, position49, tokenIndex49, false)
			position, tokenIndex = position49, tokenIndex49
			return false
		},
		/* 8 Prefix <- <((And Action Action10) / (Not Action Action11) / (And Suffix Action12) / (Not Suffix Action13) / Suffix)> */
		func() bool {
			if memoized, ok := memoization[memoKey{8, position}]; ok {
				return memoizedResult(memoized)
			}
			position53, tokenIndex53 := position, tokenIndex
			{
				position54 := position
				{
					position55, tokenIndex55 := position, tokenIndex
					if !_rules[ruleAnd]() {
						goto l56
					}
					if !_rules[ruleAction]() {
						goto l56
					}
					if !_rules[ruleAction10]() {
						goto l56
					}
					goto l55
				l56:
					position, tokenIndex = position55, tokenIndex55
					if !_rules[ruleNot]() {
						goto l57
					}
					if !_rules[ruleAction]() {
						goto l57
					}
					if !_rules[ruleAction11]() {
						goto l57
					}
					goto l55
				l57:
					position, tokenIndex = position55, tokenIndex55
					if !_rules[ruleAnd]() {
						goto l58
					}
					if !_rules[ruleSuffix]() {
						goto l58
					}
					if !_rules[ruleAction12]() {
						goto l58
					}
					goto l55
				l58:
					position, tokenIndex = position55, tokenIndex55
					if !_rules[ruleNot]() {
						goto l59
					}
					if !_rules[ruleSuffix]() {
						goto l59
					}
					if !_rules[ruleAction13]() {
						goto l59
					}
					goto l55
				l59:
					position, tokenIndex = position55, tokenIndex55
					if !_rules[ruleSuffix]() {
						goto l53
					}
				}
			l55:
				add(rulePrefix, position54)
			}
			memoize(8, position53, tokenIndex53, true)
			return true
		l53:
			memoize(8, position53, tokenIndex53, false)
			position, tokenIndex = position53, tokenIndex53
			return false
		},
		/* 9 Suffix <- <(Primary ((Question Action14) / (Star Action15) / (Plus Action16))?)> */
		func() bool {
			if memoized, ok := memoization[memoKey{9, position}]; ok {
				return memoizedResult(memoized)
			}
			position60, tokenIndex60 := position, tokenIndex
			{
				position61 := position
				if !_rules[rulePrimary]() {
					goto l60
				}
				{
					position62, tokenIndex62 := position, tokenIndex
					{
						position64, tokenIndex64 := position, tokenIndex
						if !_rules[ruleQuestion]() {
							goto l65
						}
						if !_rules[ruleAction14]() {
							goto l65
						}
						goto l64
					l65:
						position, tokenIndex = position64, tokenIndex64
						if !_rules[ruleStar]() {
							goto l66
						}
						if !_rules[ruleAction15]() {
							goto l66
						}
						goto l64
					l66:
						position, tokenIndex = position64, tokenIndex64
						if !_rules[rulePlus]() {
							goto l62
						}
						if !_rules[ruleAction16]() {
							goto l62
						}
					}
				l64:
					goto l63
				l62:
					position, tokenIndex = position62, tokenIndex62
				}
			l63:
				add(ruleSuffix, position61)
			}
			memoize(9, position60, tokenIndex60, true)
			return true
		l60:
			memoize(9, position60, tokenIndex60, false)
			position, tokenIndex = position60, tokenIndex60
			return false
		},
		/* 10 Primary <- <((Identifier !LeftArrow Action17) / (Open Expression Close) / Literal / Class / (Dot Action18) / (Action Action19) / (Begin Expression End Action20))> */
		func() bool {
			if memoized, ok := memoization[memoKey{10, position}]; ok {
				return memoizedResult(memoized)
			}
			position67, tokenIndex67 := position, tokenIndex
			{
				position68 := position
				{
					position69, tokenIndex69 := position, tokenIndex
					if !_rules[ruleIdentifier]() {
						goto l70
					}
					{
						position71, tokenIndex71 := position, tokenIndex
						if !_rules[ruleLeftArrow]() {
							goto l71
						}
						goto l70
					l71:
						position, tokenIndex = position71, tokenIndex71
					}
					if !_rules[ruleAction17]() {
						goto l70
					}
					goto l69
				l70:
					position, tokenIndex = position69, tokenIndex69
					if !_rules[ruleOpen]() {
						goto l72
					}
					if !_rules[ruleExpression]() {
						goto l72
					}
					if !_rules[ruleClose]() {
						goto l72
					}
					goto l69
				l72:
					position, tokenIndex = position69, tokenIndex69
					if !_rules[ruleLiteral]() {
						goto l73
					}
					goto l69
				l73:
					position, tokenIndex = position69, tokenIndex69
					if !_rules[ruleClass]() {
						goto l74
					}
					goto l69
				l74:
					position, tokenIndex = position69, tokenIndex69
					if !_rules[ruleDot]() {
						goto l75
					}
					if !_rules[ruleAction18]() {
						goto l75
					}
					goto l69
				l75:
					position, tokenIndex = position69, tokenIndex69
					if !_rules[ruleAction]() {
						goto l76
					}
					if !_rules[ruleAction19]() {
						goto l76
					}
					goto l69
				l76:
					position, tokenIndex = position69, tokenIndex69
					if !_rules[ruleBegin]() {
						goto l67
					}
					if !_rules[ruleExpression]() {
						goto l67
					}
					if !_rules[ruleEnd]() {
						goto l67
					}
					if !_rules[ruleAction20]() {
						goto l67
					}
				}
			l69:
				add(rulePrimary, position68)
			}
			memoize(10, position67, tokenIndex67, true)
			return true
		l67:
			memoize(10, position67, tokenIndex67, false)
			position, tokenIndex = position67, tokenIndex67
			return false
		},
		/* 11 Identifier <- <(<(IdentStart IdentCont*)> Spacing)> */
		func() bool {
			if memoized, ok := memoization[memoKey{11, position}]; ok {
				return memoizedResult(memoized)
			}
			position77, tokenIndex77 := position, tokenIndex
			{
				position78 := position
				{
					position79 := position
					if !_rules[ruleIdentStart]() {
						goto l77
					}
				l80:
					{
						position81, tokenIndex81 := position, tokenIndex
						if !_rules[ruleIdentCont]() {
							goto l81
						}
						goto l80
					l81:
						position, tokenIndex = position81, tokenIndex81
					}
					add(rulePegText, position79)
				}
				if !_rules[ruleSpacing]() {
					goto l77
				}
				add(ruleIdentifier, position78)
			}
			memoize(11, position77, tokenIndex77, true)
			return true
		l77:
			memoize(11, position77, tokenIndex77, false)
			position, tokenIndex = position77, tokenIndex77
			return false
		},
		/* 12 IdentStart <- <([a-z] / [A-Z] / '_')> */
		func() bool {
			if memoized, ok := memoization[memoKey{12, position}]; ok {
				return memoizedResult(memoized)
			}
			position82, tokenIndex82 := position, tokenIndex
			{
				position83 := position
				{
					position84, tokenIndex84 := position, tokenIndex
					if c := buffer[position]; c < rune('a') || c > rune('z') {
						goto l85
					}
					position++
					goto l84
				l85:
					position, tokenIndex = position84, tokenIndex84
					if c := buffer[position]; c < rune('A') || c > rune('Z') {
						goto l86
					}
					position++
					goto l84
				l86:
					position, tokenIndex = position84, tokenIndex84
					if buffer[position] != rune('_') {
						goto l82
					}
					position++
				}
			l84:
				add(ruleIdentStart, position83)
			}
			memoize(12, position82, tokenIndex82, true)
			return true
		l82:
			memoize(12, position82, tokenIndex82, false)
			position, tokenIndex = position82, tokenIndex82
			return false
		},
		/* 13 IdentCont <- <(IdentStart / [0-9])> */
		func() bool {
			if memoized, ok := memoization[memoKey{13, position}]; ok {
				return memoizedResult(memoized)
			}
			position87, tokenIndex87 := position, tokenIndex
			{
				position88 := position
				{
					position89, tokenIndex89 := position, tokenIndex
					if !_rules[ruleIdentStart]() {
						goto l90
					}
					goto l89
				l90:
					position, tokenIndex = position89, tokenIndex89
					if c := buffer[position]; c < rune('0') || c > rune('9') {
						goto l87
					}
					position++
				}
			l89:
				add(ruleIdentCont, position88)
			}
			memoize(13, position87, tokenIndex87, true)
			return true
		l87:
			memoize(13, position87, tokenIndex87, false)
			position, tokenIndex = position87, tokenIndex87
			return false
		},
		/* 14 Literal <- <(('\'' (!'\'' Char)? (!'\'' Char Action21)* '\'' Spacing) / ('"' (!'"' DoubleChar)? (!'"' DoubleChar Action22)* '"' Spacing))> */
		func() bool {
			if memoized, ok := memoization[memoKey{14, position}]; ok {
				return memoizedResult(memoized)
			}
			position91, tokenIndex91 := position, tokenIndex
			{
				position92 := position
				{
					position93, tokenIndex93 := position, tokenIndex
					if buffer[position] != rune('\'') {
						goto l94
					}
					position++
					{
						position95, tokenIndex95 := position, tokenIndex
						{
							position97, tokenIndex97 := position, tokenIndex
							if buffer[position] != rune('\'') {
								goto l97
							}
							position++
							goto l95
						l97:
							position, tokenIndex = position97, tokenIndex97
						}
						if !_rules[ruleChar]() {
							goto l95
						}
						goto l96
					l95:
						position, tokenIndex = position95, tokenIndex95
					}
				l96:
				l98:
					{
						position99, tokenIndex99 := position, tokenIndex
						{
							position100, tokenIndex100 := position, tokenIndex
							if buffer[position] != rune('\'') {
								goto l100
							}
							position++
							goto l99
						l100:
							position, tokenIndex = position100, tokenIndex100
						}
						if !_rules[ruleChar]() {
							goto l99
						}
						if !_rules[ruleAction21]() {
							goto l99
						}
						goto l98
					l99:
						position, tokenIndex = position99, tokenIndex99
					}
					if buffer[position] != rune('\'') {
						goto l94
					}
					position++
					if !_rules[ruleSpacing]() {
						goto l94
					}
					goto l93
				l94:
					position, tokenIndex = position93, tokenIndex93
					if buffer[position] != rune('"') {
						goto l91
					}
					position++
					{
						position101, tokenIndex101 := position, tokenIndex
						{
							position103, tokenIndex103 := position, tokenIndex
							if buffer[position] != rune('"') {
								goto l103
							}
							position++
							goto l101
						l103:
							position, tokenIndex = position103, tokenIndex103
						}
						if !_rules[ruleDoubleChar]() {
							goto l101
						}
						goto l102
					l101:
						position, tokenIndex = position101, tokenIndex101
					}
				l102:
				l104:
					{
						position105, tokenIndex105 := position, tokenIndex
						{
							position106, tokenIndex106 := position, tokenIndex
							if buffer[position] != rune('"') {
								goto l106
							}
							position++
							goto l105
						l106:
							position, tokenIndex = position106, tokenIndex106
						}
						if !_rules[ruleDoubleChar]() {
							goto l105
						}
						if !_rules[ruleAction22]() {
							goto l105
						}
						goto l104
					l105:
						position, tokenIndex = position105, tokenIndex105
					}
					if buffer[position] != rune('"') {
						goto l91
					}
					position++
					if !_rules[ruleSpacing]() {
						goto l91
					}
				}
			l93:
				add(ruleLiteral, position92)
			}
			memoize(14, position91, tokenIndex91, true)
			return true
		l91:
			memoize(14, position91, tokenIndex91, false)
			position, tokenIndex = position91, tokenIndex91
			return false
		},
		/* 15 Class <- <((('[' '[' (('^' DoubleRanges Action23) / DoubleRanges)? (']' ']')) / ('[' (('^' Ranges Action24) / Ranges)? ']')) Spacing)> */
		func() bool {
			if memoized, ok := memoization[memoKey{15, position}]; ok {
				return memoizedResult(memoized)
			}
			position107, tokenIndex107 := position, tokenIndex
			{
				position108 := position
				{
					position109, tokenIndex109 := position, tokenIndex
					if buffer[position] != rune('[') {
						goto l110
					}
					position++
					if buffer[position] != rune('[') {
						goto l110
					}
					position++
					{
						position111, tokenIndex111 := position, tokenIndex
						{
							position113, tokenIndex113 := position, tokenIndex
							if buffer[position] != rune('^') {
								goto l114
							}
							position++
							if !_rules[ruleDoubleRanges]() {
								goto l114
							}
							if !_rules[ruleAction23]() {
								goto l114
							}
							goto l113
						l114:
							position, tokenIndex = position113, tokenIndex113
							if !_rules[ruleDoubleRanges]() {
								goto l111
							}
						}
					l113:
						goto l112
					l111:
						position, tokenIndex = position111, tokenIndex111
					}
				l112:
					if buffer[position] != rune(']') {
						goto l110
					}
					position++
					if buffer[position] != rune(']') {
						goto l110
					}
					position++
					goto l109
				l110:
					position, tokenIndex = position109, tokenIndex109
					if buffer[position] != rune('[') {
						goto l107
					}
					position++
					{
						position115, tokenIndex115 := position, tokenIndex
						{
							position117, tokenIndex117 := position, tokenIndex
							if buffer[position] != rune('^') {
								goto l118
							}
							position++
							if !_rules[ruleRanges]() {
								goto l118
							}
							if !_rules[ruleAction24]() {
								goto l118
							}
							goto l117
						l118:
							position, tokenIndex = position117, tokenIndex117
							if !_rules[ruleRanges]() {
								goto l115
							}
						}
					l117:
						goto l116
					l115:
						position, tokenIndex = position115, tokenIndex115
					}
				l116:
					if buffer[position] != rune(']') {
						goto l107
					}
					position++
				}
			l109:
				if !_rules[ruleSpacing]() {
					goto l107
				}
				add(ruleClass, position108)
			}
			memoize(15, position107, tokenIndex107, true)
			return true
		l107:
			memoize(15, position107, tokenIndex107, false)
			position, tokenIndex = position107, tokenIndex107
			return false
		},
		/* 16 Ranges <- <(!']' Range (!']' Range Action25)*)> */
		func() bool {
			if memoized, ok := memoization[memoKey{16, position}]; ok {
				return memoizedResult(memoized)
			}
			position119, tokenIndex119 := position, tokenIndex
			{
				position120 := position
				{
					position121, tokenIndex121 := position, tokenIndex
					if buffer[position] != rune(']') {
						goto l121
					}
					position++
					goto l119
				l121:
					position, tokenIndex = position121, tokenIndex121
				}
				if !_rules[ruleRange]() {
					goto l119
				}
			l122:
				{
					position123, tokenIndex123 := position, tokenIndex
					{
						position124, tokenIndex124 := position, tokenIndex
						if buffer[position] != rune(']') {
							goto l124
						}
						position++
						goto l123
					l124:
						position, tokenIndex = position124, tokenIndex124
					}
					if !_rules[ruleRange]() {
						goto l123
					}
					if !_rules[ruleAction25]() {
						goto l123
					}
					goto l122
				l123:
					position, tokenIndex = position123, tokenIndex123
				}
				add(ruleRanges, position120)
			}
			memoize(16, position119, tokenIndex119, true)
			return true
		l119:
			memoize(16, position119, tokenIndex119, false)
			position, tokenIndex = position119, tokenIndex119
			return false
		},
		/* 17 DoubleRanges <- <(!(']' ']') DoubleRange (!(']' ']') DoubleRange Action26)*)> */
		func() bool {
			if memoized, ok := memoization[memoKey{17, position}]; ok {
				return memoizedResult(memoized)
			}
			position125, tokenIndex125 := position, tokenIndex
			{
				position126 := position
				{
					position127, tokenIndex127 := position, tokenIndex
					if buffer[position] != rune(']') {
						goto l127
					}
					position++
					if buffer[position] != rune(']') {
						goto l127
					}
					position++
					goto l125
				l127:
					position, tokenIndex = position127, tokenIndex127
				}
				if !_rules[ruleDoubleRange]() {
					goto l125
				}
			l128:
				{
					position129, tokenIndex129 := position, tokenIndex
					{
						position130, tokenIndex130 := position, tokenIndex
						if buffer[position] != rune(']') {
							goto l130
						}
						position++
						if buffer[position] != rune(']') {
							goto l130
						}
						position++
						goto l129
					l130:
						position, tokenIndex = position130, tokenIndex130
					}
					if !_rules[ruleDoubleRange]() {
						goto l129
					}
					if !_rules[ruleAction26]() {
						goto l129
					}
					goto l128
				l129:
					position, tokenIndex = position129, tokenIndex129
				}
				add(ruleDoubleRanges, position126)
			}
			memoize(17, position125, tokenIndex125, true)
			return true
		l125:
			memoize(17, position125, tokenIndex125, false)
			position, tokenIndex = position125, tokenIndex125
			return false
		},
		/* 18 Range <- <((Char '-' Char Action27) / Char)> */
		func() bool {
			if memoized, ok := memoization[memoKey{18, position}]; ok {
				return memoizedResult(memoized)
			}
			position131, tokenIndex131 := position, tokenIndex
			{
				position132 := position
				{
					position133, tokenIndex133 := position, tokenIndex
					if !_rules[ruleChar]() {
						goto l134
					}
					if buffer[position] != rune('-') {
						goto l134
					}
					position++
					if !_rules[ruleChar]() {
						goto l134
					}
					if !_rules[ruleAction27]() {
						goto l134
					}
					goto l133
				l134:
					position, tokenIndex = position133, tokenIndex133
					if !_rules[ruleChar]() {
						goto l131
					}
				}
			l133:
				add(ruleRange, position132)
			}
			memoize(18, position131, tokenIndex131, true)
			return true
		l131:
			memoize(18, position131, tokenIndex131, false)
			position, tokenIndex = position131, tokenIndex131
			return false
		},
		/* 19 DoubleRange <- <((Char '-' Char Action28) / DoubleChar)> */
		func() bool {
			if memoized, ok := memoization[memoKey{19, position}]; ok {
				return memoizedResult(memoized)
			}
			position135, tokenIndex135 := position, tokenIndex
			{
				position136 := position
				{
					position137, tokenIndex137 := position, tokenIndex
					if !_rules[ruleChar]() {
						goto l138
					}
					if buffer[position] != rune('-') {
						goto l138
					}
					position++
					if !_rules[ruleChar]() {
						goto l138
					}
					if !_rules[ruleAction28]() {
						goto l138
					}
					goto l137
				l138:
					position, tokenIndex = position137, tokenIndex137
					if !_rules[ruleDoubleChar]() {
						goto l135
					}
				}
			l137:
				add(ruleDoubleRange, position136)
			}
			memoize(19, position135, tokenIndex135, true)
			return true
		l135:
			memoize(19, position135, tokenIndex135, false)
			position, tokenIndex = position135, tokenIndex135
			return false
		},
		/* 20 Char <- <(Escape / (!'\\' <.> Action29))> */
		func() bool {
			if memoized, ok := memoization[memoKey{20, position}]; ok {
				return memoizedResult(memoized)
			}
			position139, tokenIndex139 := position, tokenIndex
			{
				position140 := position
				{
					position141, tokenIndex141 := position, tokenIndex
					if !_rules[ruleEscape]() {
						goto l142
					}
					goto l141
				l142:
					position, tokenIndex = position141, tokenIndex141
					{
						position143, tokenIndex143 := position, tokenIndex
						if buffer[position] != rune('\\') {
							goto l143
						}
						position++
						goto l139
					l143:
						position, tokenIndex = position143, tokenIndex143
					}
					{
						position144 := position
						if !matchDot() {
							goto l139
						}
						add(rulePegText, position144)
					}
					if !_rules[ruleAction29]() {
						goto l139
					}
				}
			l141:
				add(ruleChar, position140)
			}
			memoize(20, position139, tokenIndex139, true)
			return true
		l139:
			memoize(20, position139, tokenIndex139, false)
			position, tokenIndex = position139, tokenIndex139
			return false
		},
		/* 21 DoubleChar <- <(Escape / (<([a-z] / [A-Z])> Action30) / (!'\\' <.> Action31))> */
		func() bool {
			if memoized, ok := memoization[memoKey{21, position}]; ok {
				return memoizedResult(memoized)
			}
			position145, tokenIndex145 := position, tokenIndex
			{
				position146 := position
				{
					position147, tokenIndex147 := position, tokenIndex
					if !_rules[ruleEscape]() {
						goto l148
					}
					goto l147
				l148:
					position, tokenIndex = position147, tokenIndex147
					{
						position150 := position
						{
							position151, tokenIndex151 := position, tokenIndex
							if c := buffer[position]; c < rune('a') || c > rune('z') {
								goto l152
							}
							position++
							goto l151
						l152:
							position, tokenIndex = position151, tokenIndex151
							if c := buffer[position]; c < rune('A') || c > rune('Z') {
								goto l149
							}
							position++
						}
					l151:
						add(rulePegText, position150)
					}
					if !_rules[ruleAction30]() {
						goto l149
					}
					goto l147
				l149:
					position, tokenIndex = position147, tokenIndex147
					{
						position153, tokenIndex153 := position, tokenIndex
						if buffer[position] != rune('\\') {
							goto l153
						}
						position++
						goto l145
					l153:
						position, tokenIndex = position153, tokenIndex153
					}
					{
						position154 := position
						if !matchDot() {
							goto l145
						}
						add(rulePegText, position154)
					}
					if !_rules[ruleAction31]() {
						goto l145
					}
				}
			l147:
				add(ruleDoubleChar, position146)
			}
			memoize(21, position145, tokenIndex145, true)
			return true
		l145:
			memoize(21, position145, tokenIndex145, false)
			position, tokenIndex = position145, tokenIndex145
			return false
		},
		/* 22 Escape <- <(('\\' ('a' / 'A') Action32) / ('\\' ('b' / 'B') Action33) / ('\\' ('e' / 'E') Action34) / ('\\' ('f' / 'F') Action35) / ('\\' ('n' / 'N') Action36) / ('\\' ('r' / 'R') Action37) / ('\\' ('t' / 'T') Action38) / ('\\' ('v' / 'V') Action39) / ('\\' '\'' Action40) / ('\\' '"' Action41) / ('\\' '[' Action42) / ('\\' ']' Action43) / ('\\' '-' Action44) / ('\\' ('0' ('x' / 'X')) <([0-9] / [a-f] / [A-F])+> Action45) / ('\\' <([0-3] [0-7] [0-7])> Action46) / ('\\' <([0-7] [0-7]?)> Action47) / ('\\' '\\' Action48))> */
		func() bool {
			if memoized, ok := memoization[memoKey{22, position}]; ok {
				return memoizedResult(memoized)
			}
			position155, tokenIndex155 := position, tokenIndex
			{
				position156 := position
				{
					position157, tokenIndex157 := position, tokenIndex
					if buffer[position] != rune('\\') {
						goto l158
					}
					position++
					{
						position159, tokenIndex159 := position, tokenIndex
						if buffer[position] != rune('a') {
							goto l160
						}
						position++
						goto l159
					l160:
						position, tokenIndex = position159, tokenIndex159
						if buffer[position] != rune('A') {
							goto l158
						}
						position++
					}
				l159:
					if !_rules[ruleAction32]() {
						goto l158
					}
					goto l157
				l158:
					position, tokenIndex = position157, tokenIndex157
					if buffer[position] != rune('\\') {
						goto l161
					}
					position++
					{
						position162, tokenIndex162 := position, tokenIndex
						if buffer[position] != rune('b') {
							goto l163
						}
						position++
						goto l162
					l163:
						position, tokenIndex = position162, tokenIndex162
						if buffer[position] != rune('B') {
							goto l161
						}
						position++
					}
				l162:
					if !_rules[ruleAction33]() {
						goto l161
					}
					goto l157
				l161:
					position, tokenIndex = position157, tokenIndex157
					if buffer[position] != rune('\\') {
						goto l164
					}
					position++
					{
						position165, tokenIndex165 := position, tokenIndex
						if buffer[position] != rune('e') {
							goto l166
						}
						position++
						goto l165
					l166:
						position, tokenIndex = position165, tokenIndex165
						if buffer[position] != rune('E') {
							goto l164
						}
						position++
					}
				l165:
					if !_rules[ruleAction34]() {
						goto l164
					}
					goto l157
				l164:
					position, tokenIndex = position157, tokenIndex157
					if buffer[position] != rune('\\') {
						goto l167
					}
					position++
					{
						position168, tokenIndex168 := position, tokenIndex
						if buffer[position] != rune('f') {
							goto l169
						}
						position++
						goto l168
					l169:
						position, tokenIndex = position168, tokenIndex168
						if buffer[position] != rune('F') {
							goto l167
						}
						position++
					}
				l168:
					if !_rules[ruleAction35]() {
						goto l167
					}
					goto l157
				l167:
					position, tokenIndex = position157, tokenIndex157
					if buffer[position] != rune('\\') {
						goto l170
					}
					position++
					{
						position171, tokenIndex171 := position, tokenIndex
						if buffer[position] != rune('n') {
							goto l172
						}
						position++
						goto l171
					l172:
						position, tokenIndex = position171, tokenIndex171
						if buffer[position] != rune('N') {
							goto l170
						}
						position++
					}
				l171:
					if !_rules[ruleAction36]() {
						goto l170
					}
					goto l157
				l170:
					position, tokenIndex = position157, tokenIndex157
					if buffer[position] != rune('\\') {
						goto l173
					}
					position++
					{
						position174, tokenIndex174 := position, tokenIndex
						if buffer[position] != rune('r') {
							goto l175
						}
						position++
						goto l174
					l175:
						position, tokenIndex = position174, tokenIndex174
						if buffer[position] != rune('R') {
							goto l173
						}
						position++
					}
				l174:
					if !_rules[ruleAction37]() {
						goto l173
					}
					goto l157
				l173:
					position, tokenIndex = position157, tokenIndex157
					if buffer[position] != rune('\\') {
						goto l176
					}
					position++
					{
						position177, tokenIndex177 := position, tokenIndex
						if buffer[position] != rune('t') {
							goto l178
						}
						position++
						goto l177
					l178:
						position, tokenIndex = position177, tokenIndex177
						if buffer[position] != rune('T') {
							goto l176
						}
						position++
					}
				l177:
					if !_rules[ruleAction38]() {
						goto l176
					}
					goto l157
				l176:
					position, tokenIndex = position157, tokenIndex157
					if buffer[position] != rune('\\') {
						goto l179
					}
					position++
					{
						position180, tokenIndex180 := position, tokenIndex
						if buffer[position] != rune('v') {
							goto l181
						}
						position++
						goto l180
					l181:
						position, tokenIndex = position180, tokenIndex180
						if buffer[position] != rune('V') {
							goto l179
						}
						position++
					}
				l180:
					if !_rules[ruleAction39]() {
						goto l179
					}
					goto l157
				l179:
					position, tokenIndex = position157, tokenIndex157
					if buffer[position] != rune('\\') {
						goto l182
					}
					position++
					if buffer[position] != rune('\'') {
						goto l182
					}
					position++
					if !_rules[ruleAction40]() {
						goto l182
					}
					goto l157
				l182:
					position, tokenIndex = position157, tokenIndex157
					if buffer[position] != rune('\\') {
						goto l183
					}
					position++
					if buffer[position] != rune('"') {
						goto l183
					}
					position++
					if !_rules[ruleAction41]() {
						goto l183
					}
					goto l157
				l183:
					position, tokenIndex = position157, tokenIndex157
					if buffer[position] != rune('\\') {
						goto l184
					}
					position++
					if buffer[position] != rune('[') {
						goto l184
					}
					position++
					if !_rules[ruleAction42]() {
						goto l184
					}
					goto l157
				l184:
					position, tokenIndex = position157, tokenIndex157
					if buffer[position] != rune('\\') {
						goto l185
					}
					position++
					if buffer[position] != rune(']') {
						goto l185
					}
					position++
					if !_rules[ruleAction43]() {
						goto l185
					}
					goto l157
				l185:
					position, tokenIndex = position157, tokenIndex157
					if buffer[position] != rune('\\') {
						goto l186
					}
					position++
					if buffer[position] != rune('-') {
						goto l186
					}
					position++
					if !_rules[ruleAction44]() {
						goto l186
					}
					goto l157
				l186:
					position, tokenIndex = position157, tokenIndex157
					if buffer[position] != rune('\\') {
						goto l187
					}
					position++
					if buffer[position] != rune('0') {
						goto l187
					}
					position++
					{
						position188, tokenIndex188 := position, tokenIndex
						if buffer[position] != rune('x') {
							goto l189
						}
						position++
						goto l188
					l189:
						position, tokenIndex = position188, tokenIndex188
						if buffer[position] != rune('X') {
							goto l187
						}
						position++
					}
				l188:
					{
						position190 := position
						{
							position193, tokenIndex193 := position, tokenIndex
							if c := buffer[position]; c < rune('0') || c > rune('9') {
								goto l194
							}
							position++
							goto l193
						l194:
							position, tokenIndex = position193, tokenIndex193
							if c := buffer[position]; c < rune('a') || c > rune('f') {
								goto l195
							}
							position++
							goto l193
						l195:
							position, tokenIndex = position193, tokenIndex193
							if c := buffer[position]; c < rune('A') || c > rune('F') {
								goto l187
							}
							position++
						}
					l193:
					l191:
						{
							position192, tokenIndex192 := position, tokenIndex
							{
								position196, tokenIndex196 := position, tokenIndex
								if c := buffer[position]; c < rune('0') || c > rune('9') {
									goto l197
								}
								position++
								goto l196
							l197:
								position, tokenIndex = position196, tokenIndex196
								if c := buffer[position]; c < rune('a') || c > rune('f') {
									goto l198
								}
								position++
								goto l196
							l198:
								position, tokenIndex = position196, tokenIndex196
								if c := buffer[position]; c < rune('A') || c > rune('F') {
									goto l192
								}
								position++
							}
						l196:
							goto l191
						l192:
							position, tokenIndex = position192, tokenIndex192
						}
						add(rulePegText, position190)
					}
					if !_rules[ruleAction45]() {
						goto l187
					}
					goto l157
				l187:
					position, tokenIndex = position157, tokenIndex157
					if buffer[position] != rune('\\') {
						goto l199
					}
					position++
					{
						position200 := position
						if c := buffer[position]; c < rune('0') || c > rune('3') {
							goto l199
						}
						position++
						if c := buffer[position]; c < rune('0') || c > rune('7') {
							goto l199
						}
						position++
						if c := buffer[position]; c < rune('0') || c > rune('7') {
							goto l199
						}
						position++
						add(rulePegText, position200)
					}
					if !_rules[ruleAction46]() {
						goto l199
					}
					goto l157
				l199:
					position, tokenIndex = position157, tokenIndex157
					if buffer[position] != rune('\\') {
						goto l201
					}
					position++
					{
						position202 := position
						if c := buffer[position]; c < rune('0') || c > rune('7') {
							goto l201
						}
						position++
						{
							position203, tokenIndex203 := position, tokenIndex
							if c := buffer[position]; c < rune('0') || c > rune('7') {
								goto l203
							}
							position++
							goto l204
						l203:
							position, tokenIndex = position203, tokenIndex203
						}
					l204:
						add(rulePegText, position202)
					}
					if !_rules[ruleAction47]() {
						goto l201
					}
					goto l157
				l201:
					position, tokenIndex = position157, tokenIndex157
					if buffer[position] != rune('\\') {
						goto l155
					}
					position++
					if buffer[position] != rune('\\') {
						goto l155
					}
					position++
					if !_rules[ruleAction48]() {
						goto l155
					}
				}
			l157:
				add(ruleEscape, position156)
			}
			memoize(22, position155, tokenIndex155, true)
			return true
		l155:
			memoize(22, position155, tokenIndex155, false)
			position, tokenIndex = position155, tokenIndex155
			return false
		},
		/* 23 LeftArrow <- <((('<' '-') / '←') Spacing)> */
		func() bool {
			if memoized, ok := memoization[memoKey{23, position}]; ok {
				return memoizedResult(memoized)
			}
			position205, tokenIndex205 := position, tokenIndex
			{
				position206 := position
				{
					position207, tokenIndex207 := position, tokenIndex
					if buffer[position] != rune('<') {
						goto l208
					}
					position++
					if buffer[position] != rune('-') {
						goto l208
					}
					position++
					goto l207
				l208:
					position, tokenIndex = position207, tokenIndex207
					if buffer[position] != rune('←') {
						goto l205
					}
					position++
				}
			l207:
				if !_rules[ruleSpacing]() {
					goto l205
				}
				add(ruleLeftArrow, position206)
			}
			memoize(23, position205, tokenIndex205, true)
			return true
		l205:
			memoize(23, position205, tokenIndex205, false)
			position, tokenIndex = position205, tokenIndex205
			return false
		},
		/* 24 Slash <- <('/' Spacing)> */
		func() bool {
			if memoized, ok := memoization[memoKey{24, position}]; ok {
				return memoizedResult(memoized)
			}
			position209, tokenIndex209 := position, tokenIndex
			{
				position210 := position
				if buffer[position] != rune('/') {
					goto l209
				}
				position++
				if !_rules[ruleSpacing]() {
					goto l209
				}
				add(ruleSlash, position210)
			}
			memoize(24, position209, tokenIndex209, true)
			return true
		l209:
			memoize(24, position209, tokenIndex209, false)
			position, tokenIndex = position209, tokenIndex209
			return false
		},
		/* 25 And <- <('&' Spacing)> */
		func() bool {
			if memoized, ok := memoization[memoKey{25, position}]; ok {
				return memoizedResult(memoized)
			}
			position211, tokenIndex211 := position, tokenIndex
			{
				position212 := position
				if buffer[position] != rune('&') {
					goto l211
				}
				position++
				if !_rules[ruleSpacing]() {
					goto l211
				}
				add(ruleAnd, position212)
			}
			memoize(25, position211, tokenIndex211, true)
			return true
		l211:
			memoize(25, position211, tokenIndex211, false)
			position, tokenIndex = position211, tokenIndex211
			return false
		},
		/* 26 Not <- <('!' Spacing)> */
		func() bool {
			if memoized, ok := memoization[memoKey{26, position}]; ok {
				return memoizedResult(memoized)
			}
			position213, tokenIndex213 := position, tokenIndex
			{
				position214 := position
				if buffer[position] != rune('!') {
					goto l213
				}
				position++
				if !_rules[ruleSpacing]() {
					goto l213
				}
				add(ruleNot, position214)
			}
			memoize(26, position213, tokenIndex213, true)
			return true
		l213:
			memoize(26, position213, tokenIndex213, false)
			position, tokenIndex = position213, tokenIndex213
			return false
		},
		/* 27 Question <- <('?' Spacing)> */
		func() bool {
			if memoized, ok := memoization[memoKey{27, position}]; ok {
				return memoizedResult(memoized)
			}
			position215, tokenIndex215 := position, tokenIndex
			{
				position216 := position
				if buffer[position] != rune('?') {
					goto l215
				}
				position++
				if !_rules[ruleSpacing]() {
					goto l215
				}
				add(ruleQuestion, position216)
			}
			memoize(27, position215, tokenIndex215, true)
			return true
		l215:
			memoize(27, position215, tokenIndex215, false)
			position, tokenIndex = position215, tokenIndex215
			return false
		},
		/* 28 Star <- <('*' Spacing)> */
		func() bool {
			if memoized, ok := memoization[memoKey{28, position}]; ok {
				return memoizedResult(memoized)
			}
			position217, tokenIndex217 := position, tokenIndex
			{
				position218 := position
				if buffer[position] != rune('*') {
					goto l217
				}
				position++
				if !_rules[ruleSpacing]() {
					goto l217
				}
				add(ruleStar, position218)
			}
			memoize(28, position217, tokenIndex217, true)
			return true
		l217:
			memoize(28, position217, tokenIndex217, false)
			position, tokenIndex = position217, tokenIndex217
			return false
		},
		/* 29 Plus <- <('+' Spacing)> */
		func() bool {
			if memoized, ok := memoization[memoKey{29, position}]; ok {
				return memoizedResult(memoized)
			}
			position219, tokenIndex219 := position, tokenIndex
			{
				position220 := position
				if buffer[position] != rune('+') {
					goto l219
				}
				position++
				if !_rules[ruleSpacing]() {
					goto l219
				}
				add(rulePlus, position220)
			}
			memoize(29, position219, tokenIndex219, true)
			return true
		l219:
			memoize(29, position219, tokenIndex219, false)
			position, tokenIndex = position219, tokenIndex219
			return false
		},
		/* 30 Open <- <('(' Spacing)> */
		func() bool {
			if memoized, ok := memoization[memoKey{30, position}]; ok {
				return memoizedResult(memoized)
			}
			position221, tokenIndex221 := position, tokenIndex
			{
				position222 := position
				if buffer[position] != rune('(') {
					goto l221
				}
				position++
				if !_rules[ruleSpacing]() {
					goto l221
				}
				add(ruleOpen, position222)
			}
			memoize(30, position221, tokenIndex221, true)
			return true
		l221:
			memoize(30, position221, tokenIndex221, false)
			position, tokenIndex = position221, tokenIndex221
			return false
		},
		/* 31 Close <- <(')' Spacing)> */
		func() bool {
			if memoized, ok := memoization[memoKey{31, position}]; ok {
				return memoizedResult(memoized)
			}
			position223, tokenIndex223 := position, tokenIndex
			{
				position224 := position
				if buffer[position] != rune(')') {
					goto l223
				}
				position++
				if !_rules[ruleSpacing]() {
					goto l223
				}
				add(ruleClose, position224)
			}
			memoize(31, position223, tokenIndex223, true)
			return true
		l223:
			memoize(31, position223, tokenIndex223, false)
			position, tokenIndex = position223, tokenIndex223
			return false
		},
		/* 32 Dot <- <('.' Spacing)> */
		func() bool {
			if memoized, ok := memoization[memoKey{32, position}]; ok {
				return memoizedResult(memoized)
			}
			position225, tokenIndex225 := position, tokenIndex
			{
				position226 := position
				if buffer[position] != rune('.') {
					goto l225
				}
				position++
				if !_rules[ruleSpacing]() {
					goto l225
				}
				add(ruleDot, position226)
			}
			memoize(32, position225, tokenIndex225, true)
			return true
		l225:
			memoize(32, position225, tokenIndex225, false)
			position, tokenIndex = position225, tokenIndex225
			return false
		},
		/* 33 SpaceComment <- <(Space / Comment)> */
		func() bool {
			if memoized, ok := memoization[memoKey{33, position}]; ok {
				return memoizedResult(memoized)
			}
			position227, tokenIndex227 := position, tokenIndex
			{
				position228 := position
				{
					position229, tokenIndex229 := position, tokenIndex
					if !_rules[ruleSpace]() {
						goto l230
					}
					goto l229
				l230:
					position, tokenIndex = position229, tokenIndex229
					if !_rules[ruleComment]() {
						goto l227
					}
				}
			l229:
				add(ruleSpaceComment, position228)
			}
			memoize(33, position227, tokenIndex227, true)
			return true
		l227:
			memoize(33, position227, tokenIndex227, false)
			position, tokenIndex = position227, tokenIndex227
			return false
		},
		/* 34 Spacing <- <SpaceComment*> */
		func() bool {
			if memoized, ok := memoization[memoKey{34, position}]; ok {
				return memoizedResult(memoized)
			}
			position231, tokenIndex231 := position, tokenIndex
			{
				position232 := position
			l233:
				{
					position234, tokenIndex234 := position, tokenIndex
					if !_rules[ruleSpaceComment]() {
						goto l234
					}
					goto l233
				l234:
					position, tokenIndex = position234, tokenIndex234
				}
				add(ruleSpacing, position232)
			}
			memoize(34, position231, tokenIndex231, true)
			return true
		},
		/* 35 MustSpacing <- <SpaceComment+> */
		func() bool {
			if memoized, ok := memoization[memoKey{35, position}]; ok {
				return memoizedResult(memoized)
			}
			position235, tokenIndex235 := position, tokenIndex
			{
				position236 := position
				if !_rules[ruleSpaceComment]() {
					goto l235
				}
			l237:
				{
					position238, tokenIndex238 := position, tokenIndex
					if !_rules[ruleSpaceComment]() {
						goto l238
					}
					goto l237
				l238:
					position, tokenIndex = position238, tokenIndex238
				}
				add(ruleMustSpacing, position236)
			}
			memoize(35, position235, tokenIndex235, true)
			return true
		l235:
			memoize(35, position235, tokenIndex235, false)
			position, tokenIndex = position235, tokenIndex235
			return false
		},
		/* 36 Comment <- <(('#' / ('/' '/')) (!EndOfLine .)* EndOfLine)> */
		func() bool {
			if memoized, ok := memoization[memoKey{36, position}]; ok {
				return memoizedResult(memoized)
			}
			position239, tokenIndex239 := position, tokenIndex
			{
				position240 := position
				{
					position241, tokenIndex241 := position, tokenIndex
					if buffer[position] != rune('#') {
						goto l242
					}
					position++
					goto l241
				l242:
					position, tokenIndex = position241, tokenIndex241
					if buffer[position] != rune('/') {
						goto l239
					}
					position++
					if buffer[position] != rune('/') {
						goto l239
					}
					position++
				}
			l241:
			l243:
				{
					position244, tokenIndex244 := position, tokenIndex
					{
						position245, tokenIndex245 := position, tokenIndex
						if !_rules[ruleEndOfLine]() {
							goto l245
						}
						goto l244
					l245:
						position, tokenIndex = position245, tokenIndex245
					}
					if !matchDot() {
						goto l244
					}
					goto l243
				l244:
					position, tokenIndex = position244, tokenIndex244
				}
				if !_rules[ruleEndOfLine]() {
					goto l239
				}
				add(ruleComment, position240)
			}
			memoize(36, position239, tokenIndex239, true)
			return true
		l239:
			memoize(36, position239, tokenIndex239, false)
			position, tokenIndex = position239, tokenIndex239
			return false
		},
		/* 37 Space <- <(' ' / '\t' / EndOfLine)> */
		func() bool {
			if memoized, ok := memoization[memoKey{37, position}]; ok {
				return memoizedResult(memoized)
			}
			position246, tokenIndex246 := position, tokenIndex
			{
				position247 := position
				{
					position248, tokenIndex248 := position, tokenIndex
					if buffer[position] != rune(' ') {
						goto l249
					}
					position++
					goto l248
				l249:
					position, tokenIndex = position248, tokenIndex248
					if buffer[position] != rune('\t') {
						goto l250
					}
					position++
					goto l248
				l250:
					position, tokenIndex = position248, tokenIndex248
					if !_rules[ruleEndOfLine]() {
						goto l246
					}
				}
			l248:
				add(ruleSpace, position247)
			}
			memoize(37, position246, tokenIndex246, true)
			return true
		l246:
			memoize(37, position246, tokenIndex246, false)
			position, tokenIndex = position246, tokenIndex246
			return false
		},
		/* 38 EndOfLine <- <(('\r' '\n') / '\n' / '\r')> */
		func() bool {
			if memoized, ok := memoization[memoKey{38, position}]; ok {
				return memoizedResult(memoized)
			}
			position251, tokenIndex251 := position, tokenIndex
			{
				position252 := position
				{
					position253, tokenIndex253 := position, tokenIndex
					if buffer[position] != rune('\r') {
						goto l254
					}
					position++
					if buffer[position] != rune('\n') {
						goto l254
					}
					position++
					goto l253
				l254:
					position, tokenIndex = position253, tokenIndex253
					if buffer[position] != rune('\n') {
						goto l255
					}
					position++
					goto l253
				l255:
					position, tokenIndex = position253, tokenIndex253
					if buffer[position] != rune('\r') {
						goto l251
					}
					position++
				}
			l253:
				add(ruleEndOfLine, position252)
			}
			memoize(38, position251, tokenIndex251, true)
			return true
		l251:
			memoize(38, position251, tokenIndex251, false)
			position, tokenIndex = position251, tokenIndex251
			return false
		},
		/* 39 EndOfFile <- <!.> */
		func() bool {
			if memoized, ok := memoization[memoKey{39, position}]; ok {
				return memoizedResult(memoized)
			}
			position256, tokenIndex256 := position, tokenIndex
			{
				position257 := position
				{
					position258, tokenIndex258 := position, tokenIndex
					if !matchDot() {
						goto l258
					}
					goto l256
				l258:
					position, tokenIndex = position258, tokenIndex258
				}
				add(ruleEndOfFile, position257)
			}
			memoize(39, position256, tokenIndex256, true)
			return true
		l256:
			memoize(39, position256, tokenIndex256, false)
			position, tokenIndex = position256, tokenIndex256
			return false
		},
		/* 40 Action <- <('{' <ActionBody*> '}' Spacing)> */
		func() bool {
			if memoized, ok := memoization[memoKey{40, position}]; ok {
				return memoizedResult(memoized)
			}
			position259, tokenIndex259 := position, tokenIndex
			{
				position260 := position
				if buffer[position] != rune('{') {
					goto l259
				}
				position++
				{
					position261 := position
				l262:
					{
						position263, tokenIndex263 := position, tokenIndex
						if !_rules[ruleActionBody]() {
							goto l263
						}
						goto l262
					l263:
						position, tokenIndex = position263, tokenIndex263
					}
					add(rulePegText, position261)
				}
				if buffer[position] != rune('}') {
					goto l259
				}
				position++
				if !_rules[ruleSpacing]() {
					goto l259
				}
				add(ruleAction, position260)
			}
			memoize(40, position259, tokenIndex259, true)
			return true
		l259:
			memoize(40, position259, tokenIndex259, false)
			position, tokenIndex = position259, tokenIndex259
			return false
		},
		/* 41 ActionBody <- <((!('{' / '}') .) / ('{' ActionBody* '}'))> */
		func() bool {
			if memoized, ok := memoization[memoKey{41, position}]; ok {
				return memoizedResult(memoized)
			}
			position264, tokenIndex264 := position, tokenIndex
			{
				position265 := position
				{
					position266, tokenIndex266 := position, tokenIndex
					{
						position268, tokenIndex268 := position, tokenIndex
						{
							position269, tokenIndex269 := position, tokenIndex
							if buffer[position] != rune('{') {
								goto l270
							}
							position++
							goto l269
						l270:
							position, tokenIndex = position269, tokenIndex269
							if buffer[position] != rune('}') {
								goto l268
							}
							position++
						}
					l269:
						goto l267
					l268:
						position, tokenIndex = position268, tokenIndex268
					}
					if !matchDot() {
						goto l267
					}
					goto l266
				l267:
					position, tokenIndex = position266, tokenIndex266
					if buffer[position] != rune('{') {
						goto l264
					}
					position++
				l271:
					{
						position272, tokenIndex272 := position, tokenIndex
						if !_rules[ruleActionBody]() {
							goto l272
						}
						goto l271
					l272:
						position, tokenIndex = position272, tokenIndex272
					}
					if buffer[position] != rune('}') {
						goto l264
					}
					position++
				}
			l266:
				add(ruleActionBody, position265)
			}
			memoize(41, position264, tokenIndex264, true)
			return true
		l264:
			memoize(41, position264, tokenIndex264, false)
			position, tokenIndex = position264, tokenIndex264
			return false
		},
		/* 42 Begin <- <('<' Spacing)> */
		func() bool {
			if memoized, ok := memoization[memoKey{42, position}]; ok {
				return memoizedResult(memoized)
			}
			position273, tokenIndex273 := position, tokenIndex
			{
				position274 := position
				if buffer[position] != rune('<') {
					goto l273
				}
				position++
				if !_rules[ruleSpacing]() {
					goto l273
				}
				add(ruleBegin, position274)
			}
			memoize(42, position273, tokenIndex273, true)
			return true
		l273:
			memoize(42, position273, tokenIndex273, false)
			position, tokenIndex = position273, tokenIndex273
			return false
		},
		/* 43 End <- <('>' Spacing)> */
		func() bool {
			if memoized, ok := memoization[memoKey{43, position}]; ok {
				return memoizedResult(memoized)
			}
			position275, tokenIndex275 := position, tokenIndex
			{
				position276 := position
				if buffer[position] != rune('>') {
					goto l275
				}
				position++
				if !_rules[ruleSpacing]() {
					goto l275
				}
				add(ruleEnd, position276)
			}
			memoize(43, position275, tokenIndex275, true)
			return true
		l275:
			memoize(43, position275, tokenIndex275, false)
			position, tokenIndex = position275, tokenIndex275
			return false
		},
		/* 45 Action0 <- <{ p.AddPackage(text) }> */
		func() bool {
			if memoized, ok := memoization[memoKey{45, position}]; ok {
				return memoizedResult(memoized)
			}
			position277, tokenIndex277 := position, tokenIndex
			{
				add(ruleAction0, position)
			}
			memoize(45, position277, tokenIndex277, true)
			return true
		},
		/* 46 Action1 <- <{ p.AddPeg(text) }> */
		func() bool {
			if memoized, ok := memoization[memoKey{46, position}]; ok {
				return memoizedResult(memoized)
			}
			position279, tokenIndex279 := position, tokenIndex
			{
				add(ruleAction1, position)
			}
			memoize(46, position279, tokenIndex279, true)
			return true
		},
		/* 47 Action2 <- <{ p.AddState(text) }> */
		func() bool {
			if memoized, ok := memoization[memoKey{47, position}]; ok {
				return memoizedResult(memoized)
			}
			position281, tokenIndex281 := position, tokenIndex
			{
				add(ruleAction2, position)
			}
			memoize(47, position281, tokenIndex281, true)
			return true
		},
		nil,
		/* 49 Action3 <- <{ p.AddImport(text) }> */
		func() bool {
			if memoized, ok := memoization[memoKey{49, position}]; ok {
				return memoizedResult(memoized)
			}
			position283, tokenIndex283 := position, tokenIndex
			{
				add(ruleAction3, position)
			}
			memoize(49, position283, tokenIndex283, true)
			return true
		},
		/* 50 Action4 <- <{ p.AddRule(text) }> */
		func() bool {
			if memoized, ok := memoization[memoKey{50, position}]; ok {
				return memoizedResult(memoized)
			}
			position285, tokenIndex285 := position, tokenIndex
			{
				add(ruleAction4, position)
			}
			memoize(50, position285, tokenIndex285, true)
			return true
		},
		/* 51 Action5 <- <{ p.AddExpression() }> */
		func() bool {
			if memoized, ok := memoization[memoKey{51, position}]; ok {
				return memoizedResult(memoized)
			}
			position287, tokenIndex287 := position, tokenIndex
			{
				add(ruleAction5, position)
			}
			memoize(51, position287, tokenIndex287, true)
			return true
		},
		/* 52 Action6 <- <{ p.AddAlternate() }> */
		func() bool {
			if memoized, ok := memoization[memoKey{52, position}]; ok {
				return memoizedResult(memoized)
			}
			position289, tokenIndex289 := position, tokenIndex
			{
				add(ruleAction6, position)
			}
			memoize(52, position289, tokenIndex289, true)
			return true
		},
		/* 53 Action7 <- <{ p.AddNil(); p.AddAlternate() }> */
		func() bool {
			if memoized, ok := memoization[memoKey{53, position}]; ok {
				return memoizedResult(memoized)
			}
			position291, tokenIndex291 := position, tokenIndex
			{
				add(ruleAction7, position)
			}
			memoize(53, position291, tokenIndex291, true)
			return true
		},
		/* 54 Action8 <- <{ p.AddNil() }> */
		func() bool {
			if memoized, ok := memoization[memoKey{54, position}]; ok {
				return memoizedResult(memoized)
			}
			position293, tokenIndex293 := position, tokenIndex
			{
				add(ruleAction8, position)
			}
			memoize(54, position293, tokenIndex293, true)
			return true
		},
		/* 55 Action9 <- <{ p.AddSequence() }> */
		func() bool {
			if memoized, ok := memoization[memoKey{55, position}]; ok {
				return memoizedResult(memoized)
			}
			position295, tokenIndex295 := position, tokenIndex
			{
				add(ruleAction9, position)
			}
			memoize(55, position295, tokenIndex295, true)
			return true
		},
		/* 56 Action10 <- <{ p.AddPredicate(text) }> */
		func() bool {
			if memoized, ok := memoization[memoKey{56, position}]; ok {
				return memoizedResult(memoized)
			}
			position297, tokenIndex297 := position, tokenIndex
			{
				add(ruleAction10, position)
			}
			memoize(56, position297, tokenIndex297, true)
			return true
		},
		/* 57 Action11 <- <{ p.AddStateChange(text) }> */
		func() bool {
			if memoized, ok := memoization[memoKey{57, position}]; ok {
				return memoizedResult(memoized)
			}
			position299, tokenIndex299 := position, tokenIndex
			{
				add(ruleAction11, position)
			}
			memoize(57, position299, tokenIndex299, true)
			return true
		},
		/* 58 Action12 <- <{ p.AddPeekFor() }> */
		func() bool {
			if memoized, ok := memoization[memoKey{58, position}]; ok {
				return memoizedResult(memoized)
			}
			position301, tokenIndex301 := position, tokenIndex
			{
				add(ruleAction12, position)
			}
			memoize(58, position301, tokenIndex301, true)
			return true
		},
		/* 59 Action13 <- <{ p.AddPeekNot() }> */
		func() bool {
			if memoized, ok := memoization[memoKey{59, position}]; ok {
				return memoizedResult(memoized)
			}
			position303, tokenIndex303 := position, tokenIndex
			{
				add(ruleAction13, position)
			}
			memoize(59, position303, tokenIndex303, true)
			return true
		},
		/* 60 Action14 <- <{ p.AddQuery() }> */
		func() bool {
			if memoized, ok := memoization[memoKey{60, position}]; ok {
				return memoizedResult(memoized)
			}
			position305, tokenIndex305 := position, tokenIndex
			{
				add(ruleAction14, position)
			}
			memoize(60, position305, tokenIndex305, true)
			return true
		},
		/* 61 Action15 <- <{ p.AddStar() }> */
		func() bool {
			if memoized, ok := memoization[memoKey{61, position}]; ok {
				return memoizedResult(memoized)
			}
			position307, tokenIndex307 := position, tokenIndex
			{
				add(ruleAction15, position)
			}
			memoize(61, position307, tokenIndex307, true)
			return true
		},
		/* 62 Action16 <- <{ p.AddPlus() }> */
		func() bool {
			if memoized, ok := memoization[memoKey{62, position}]; ok {
				return memoizedResult(memoized)
			}
			position309, tokenIndex309 := position, tokenIndex
			{
				add(ruleAction16, position)
			}
			memoize(62, position309, tokenIndex309, true)
			return true
		},
		/* 63 Action17 <- <{ p.AddName(text) }> */
		func() bool {
			if memoized, ok := memoization[memoKey{63, position}]; ok {
				return memoizedResult(memoized)
			}
			position311, tokenIndex311 := position, tokenIndex
			{
				add(ruleAction17, position)
			}
			memoize(63, position311, tokenIndex311, true)
			return true
		},
		/* 64 Action18 <- <{ p.AddDot() }> */
		func() bool {
			if memoized, ok := memoization[memoKey{64, position}]; ok {
				return memoizedResult(memoized)
			}
			position313, tokenIndex313 := position, tokenIndex
			{
				add(ruleAction18, position)
			}
			memoize(64, position313, tokenIndex313, true)
			return true
		},
		/* 65 Action19 <- <{ p.AddAction(text) }> */
		func() bool {
			if memoized, ok := memoization[memoKey{65, position}]; ok {
				return memoizedResult(memoized)
			}
			position315, tokenIndex315 := position, tokenIndex
			{
				add(ruleAction19, position)
			}
			memoize(65, position315, tokenIndex315, true)
			return true
		},
		/* 66 Action20 <- <{ p.AddPush() }> */
		func() bool {
			if memoized, ok := memoization[memoKey{66, position}]; ok {
				return memoizedResult(memoized)
			}
			position317, tokenIndex317 := position, tokenIndex
			{
				add(ruleAction20, position)
			}
			memoize(66, position317, tokenIndex317, true)
			return true
		},
		/* 67 Action21 <- <{ p.AddSequence() }> */
		func() bool {
			if memoized, ok := memoization[memoKey{67, position}]; ok {
				return memoizedResult(memoized)
			}
			position319, tokenIndex319 := position, tokenIndex
			{
				add(ruleAction21, position)
			}
			memoize(67, position319, tokenIndex319, true)
			return true
		},
		/* 68 Action22 <- <{ p.AddSequence() }> */
		func() bool {
			if memoized, ok := memoization[memoKey{68, position}]; ok {
				return memoizedResult(memoized)
			}
			position321, tokenIndex321 := position, tokenIndex
			{
				add(ruleAction22, position)
			}
			memoize(68, position321, tokenIndex321, true)
			return true
		},
		/* 69 Action23 <- <{ p.AddPeekNot(); p.AddDot(); p.AddSequence() }> */
		func() bool {
			if memoized, ok := memoization[memoKey{69, position}]; ok {
				return memoizedResult(memoized)
			}
			position323, tokenIndex323 := position, tokenIndex
			{
				add(ruleAction23, position)
			}
			memoize(69, position323, tokenIndex323, true)
			return true
		},
		/* 70 Action24 <- <{ p.AddPeekNot(); p.AddDot(); p.AddSequence() }> */
		func() bool {
			if memoized, ok := memoization[memoKey{70, position}]; ok {
				return memoizedResult(memoized)
			}
			position325, tokenIndex325 := position, tokenIndex
			{
				add(ruleAction24, position)
			}
			memoize(70, position325, tokenIndex325, true)
			return true
		},
		/* 71 Action25 <- <{ p.AddAlternate() }> */
		func() bool {
			if memoized, ok := memoization[memoKey{71, position}]; ok {
				return memoizedResult(memoized)
			}
			position327, tokenIndex327 := position, tokenIndex
			{
				add(ruleAction25, position)
			}
			memoize(71, position327, tokenIndex327, true)
			return true
		},
		/* 72 Action26 <- <{ p.AddAlternate() }> */
		func() bool {
			if memoized, ok := memoization[memoKey{72, position}]; ok {
				return memoizedResult(memoized)
			}
			position329, tokenIndex329 := position, tokenIndex
			{
				add(ruleAction26, position)
			}
			memoize(72, position329, tokenIndex329, true)
			return true
		},
		/* 73 Action27 <- <{ p.AddRange() }> */
		func() bool {
			if memoized, ok := memoization[memoKey{73, position}]; ok {
				return memoizedResult(memoized)
			}
			position331, tokenIndex331 := position, tokenIndex
			{
				add(ruleAction27, position)
			}
			memoize(73, position331, tokenIndex331, true)
			return true
		},
		/* 74 Action28 <- <{ p.AddDoubleRange() }> */
		func() bool {
			if memoized, ok := memoization[memoKey{74, position}]; ok {
				return memoizedResult(memoized)
			}
			position333, tokenIndex333 := position, tokenIndex
			{
				add(ruleAction28, position)
			}
			memoize(74, position333, tokenIndex333, true)
			return true
		},
		/* 75 Action29 <- <{ p.AddCharacter(text) }> */
		func() bool {
			if memoized, ok := memoization[memoKey{75, position}]; ok {
				return memoizedResult(memoized)
			}
			position335, tokenIndex335 := position, tokenIndex
			{
				add(ruleAction29, position)
			}
			memoize(75, position335, tokenIndex335, true)
			return true
		},
		/* 76 Action30 <- <{ p.AddDoubleCharacter(text) }> */
		func() bool {
			if memoized, ok := memoization[memoKey{76, position}]; ok {
				return memoizedResult(memoized)
			}
			position337, tokenIndex337 := position, tokenIndex
			{
				add(ruleAction30, position)
			}
			memoize(76, position337, tokenIndex337, true)
			return true
		},
		/* 77 Action31 <- <{ p.AddCharacter(text) }> */
		func() bool {
			if memoized, ok := memoization[memoKey{77, position}]; ok {
				return memoizedResult(memoized)
			}
			position339, tokenIndex339 := position, tokenIndex
			{
				add(ruleAction31, position)
			}
			memoize(77, position339, tokenIndex339, true)
			return true
		},
		/* 78 Action32 <- <{ p.AddCharacter("\a") }> */
		func() bool {
			if memoized, ok := memoization[memoKey{78, position}]; ok {
				return memoizedResult(memoized)
			}
			position341, tokenIndex341 := position, tokenIndex
			{
				add(ruleAction32, position)
			}
			memoize(78, position341, tokenIndex341, true)
			return true
		},
		/* 79 Action33 <- <{ p.AddCharacter("\b") }> */
		func() bool {
			if memoized, ok := memoization[memoKey{79, position}]; ok {
				return memoizedResult(memoized)
			}
			position343, tokenIndex343 := position, tokenIndex
			{
				add(ruleAction33, position)
			}
			memoize(79, position343, tokenIndex343, true)
			return true
		},
		/* 80 Action34 <- <{ p.AddCharacter("\x1B") }> */
		func() bool {
			if memoized, ok := memoization[memoKey{80, position}]; ok {
				return memoizedResult(memoized)
			}
			position345, tokenIndex345 := position, tokenIndex
			{
				add(ruleAction34, position)
			}
			memoize(80, position345, tokenIndex345, true)
			return true
		},
		/* 81 Action35 <- <{ p.AddCharacter("\f") }> */
		func() bool {
			if memoized, ok := memoization[memoKey{81, position}]; ok {
				return memoizedResult(memoized)
			}
			position347, tokenIndex347 := position, tokenIndex
			{
				add(ruleAction35, position)
			}
			memoize(81, position347, tokenIndex347, true)
			return true
		},
		/* 82 Action36 <- <{ p.AddCharacter("\n") }> */
		func() bool {
			if memoized, ok := memoization[memoKey{82, position}]; ok {
				return memoizedResult(memoized)
			}
			position349, tokenIndex349 := position, tokenIndex
			{
				add(ruleAction36, position)
			}
			memoize(82, position349, tokenIndex349, true)
			return true
		},
		/* 83 Action37 <- <{ p.AddCharacter("\r") }> */
		func() bool {
			if memoized, ok := memoization[memoKey{83, position}]; ok {
				return memoizedResult(memoized)
			}
			position351, tokenIndex351 := position, tokenIndex
			{
				add(ruleAction37, position)
			}
			memoize(83, position351, tokenIndex351, true)
			return true
		},
		/* 84 Action38 <- <{ p.AddCharacter("\t") }> */
		func() bool {
			if memoized, ok := memoization[memoKey{84, position}]; ok {
				return memoizedResult(memoized)
			}
			position353, tokenIndex353 := position, tokenIndex
			{
				add(ruleAction38, position)
			}
			memoize(84, position353, tokenIndex353, true)
			return true
		},
		/* 85 Action39 <- <{ p.AddCharacter("\v") }> */
		func() bool {
			if memoized, ok := memoization[memoKey{85, position}]; ok {
				return memoizedResult(memoized)
			}
			position355, tokenIndex355 := position, tokenIndex
			{
				add(ruleAction39, position)
			}
			memoize(85, position355, tokenIndex355, true)
			return true
		},
		/* 86 Action40 <- <{ p.AddCharacter("'") }> */
		func() bool {
			if memoized, ok := memoization[memoKey{86, position}]; ok {
				return memoizedResult(memoized)
			}
			position357, tokenIndex357 := position, tokenIndex
			{
				add(ruleAction40, position)
			}
			memoize(86, position357, tokenIndex357, true)
			return true
		},
		/* 87 Action41 <- <{ p.AddCharacter("\"") }> */
		func() bool {
			if memoized, ok := memoization[memoKey{87, position}]; ok {
				return memoizedResult(memoized)
			}
			position359, tokenIndex359 := position, tokenIndex
			{
				add(ruleAction41, position)
			}
			memoize(87, position359, tokenIndex359, true)
			return true
		},
		/* 88 Action42 <- <{ p.AddCharacter("[") }> */
		func() bool {
			if memoized, ok := memoization[memoKey{88, position}]; ok {
				return memoizedResult(memoized)
			}
			position361, tokenIndex361 := position, tokenIndex
			{
				add(ruleAction42, position)
			}
			memoize(88, position361, tokenIndex361, true)
			return true
		},
		/* 89 Action43 <- <{ p.AddCharacter("]") }> */
		func() bool {
			if memoized, ok := memoization[memoKey{89, position}]; ok {
				return memoizedResult(memoized)
			}
			position363, tokenIndex363 := position, tokenIndex
			{
				add(ruleAction43, position)
			}
			memoize(89, position363, tokenIndex363, true)
			return true
		},
		/* 90 Action44 <- <{ p.AddCharacter("-") }> */
		func() bool {
			if memoized, ok := memoization[memoKey{90, position}]; ok {
				return memoizedResult(memoized)
			}
			position365, tokenIndex365 := position, tokenIndex
			{
				add(ruleAction44, position)
			}
			memoize(90, position365, tokenIndex365, true)
			return true
		},
		/* 91 Action45 <- <{ p.AddHexaCharacter(text) }> */
		func() bool {
			if memoized, ok := memoization[memoKey{91, position}]; ok {
				return memoizedResult(memoized)
			}
			position367, tokenIndex367 := position, tokenIndex
			{
				add(ruleAction45, position)
			}
			memoize(91, position367, tokenIndex367, true)
			return true
		},
		/* 92 Action46 <- <{ p.AddOctalCharacter(text) }> */
		func() bool {
			if memoized, ok := memoization[memoKey{92, position}]; ok {
				return memoizedResult(memoized)
			}
			position369, tokenIndex369 := position, tokenIndex
			{
				add(ruleAction46, position)
			}
			memoize(92, position369, tokenIndex369, true)
			return true
		},
		/* 93 Action47 <- <{ p.AddOctalCharacter(text) }> */
		func() bool {
			if memoized, ok := memoization[memoKey{93, position}]; ok {
				return memoizedResult(memoized)
			}
			position371, tokenIndex371 := position, tokenIndex
			{
				add(ruleAction47, position)
			}
			memoize(93, position371, tokenIndex371, true)
			return true
		},
		/* 94 Action48 <- <{ p.AddCharacter("\\") }> */
		func() bool {
			if memoized, ok := memoization[memoKey{94, position}]; ok {
				return memoizedResult(memoized)
			}
			position373, tokenIndex373 := position, tokenIndex
			{
				add(ruleAction48, position)
			}
			memoize(94, position373, tokenIndex373, true)
			return true
		},
	}
	p.rules = _rules
	return nil
}
